[TOC]

# MySQL的事务特性(ACID规则)
事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：

1. A (Atomicity) 原子性
原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。
比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。

2. C (Consistency) 一致性
一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。
例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。

3. I (Isolation) 独立性
所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。
比如现在有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。

4. D (Durability) 持久性
持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。

# UNION ALL 与 UNION 的区别
UNION和UNION ALL关键字都是将两个结果集合并为一个。
UNION在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。
而UNION ALL只是简单的将两个结果合并后就返回。
由于UNION需要排序去重，所以 UNION ALL 的效率比 UNION 好很多。

# TRUNCATE 与 DELETE 区别
TRUNCATE 是DDL语句，而 DELETE 是DML语句。
TRUNCATE 是先把整张表drop调，然后重建该表。而 DELETE 是一行一行的删除，所以 TRUNCATE 的速度肯定比 DELETE 速度快。
TRUNCATE 不可以回滚，DELETE 可以。
TRUNCATE 执行结果只是返回0 rows affected，可以解释为没有返回结果。
TRUNCATE 会重置水平线（自增长列起始位），DELETE 不会。
TRUNCATE 只能清理整张表，DELETE 可以按照条件删除。
一般情景下，TRUNCATE性能比DELETE好一点。

# TIMESTAMP 与 DATETIME 的区别

相同点
TIMESTAMP 列的显示格式与 DATETIME 列相同。显示列宽固定在19字符，并且格式为YYYY-MM-DD HH:MM:SS。
不同点
TIMESTAMP
4个字节存储，时间范围：1970-01-01 08:00:01~2038-01-19 11:14:07。
值以UTC格式保存，涉及时区转化，存储时对当前的时区进行转换，检索时再转换回当前的时区。
DATETIME
8个字节存储，时间范围：1000-10-01 00:00:00~9999-12-31 23:59:59。
实际格式存储，与时区无关。

# 什么是联合索引
两个或更多个列上的索引被称作联合索引，联合索引又叫复合索引。

## 为什么要使用联合索引
减少开销：建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。减少磁盘空间的开销。
覆盖索引：对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。覆盖索引是主要的提升性能的优化手段之一。
效率高：索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql select from table where col1=1 and col2=2 and col3=3，假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W\*10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w\*10%\*10%\*10%=1w，效率得到明显提升。

## MySQL 联合索引最左匹配原则
在 MySQL 建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
MySQL 会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
= 和 in 可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

# 什么是聚集和非聚集索引
聚集索引就是以主键创建的索引。
非聚集索引就是以非主键创建的索引。

# 什么是覆盖索引
覆盖索引（covering index）指一个查询语句的执行只用从索引页中就能够取得（如果不是聚集索引，叶子节点存储的是主键+列值，最终还是要回表，也就是要通过主键再查找一次），避免了查到索引后，再做回表操作，减少I/O提高效率。
可以结合第10个问题更容易理解。

# 什么是前缀索引

前缀索引就是对文本的前几个字符（具体是几个字符在创建索引时指定）创建索引，这样创建起来的索引更小。但是MySQL不能在ORDER BY或GROUP BY中使用前缀索引，也不能把它们用作覆盖索引。

创建前缀索引的语法：
```sql
ALTER TABLE table_name ADD
KEY(column_name(prefix_length))
```

# InnoDB 与 MyISAM 索引存储结构的区别
MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。
而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，所以必须有主键，如果没有显示定义，自动为生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。
InnoDB的辅助索引（Secondary Index，也就是非主键索引）存储的只是主键列和索引列，如果主键定义的比较大，其他索引也将很大。
MyISAM引擎使用B+Tree作为索引结构，索引文件叶节点的data域存放的是数据记录的地址，指向数据文件中对应的值，每个节点只有该索引列的值。
MyISAM主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，辅助索引可以重复，（由于MyISAM辅助索引在叶子节点上存储的是数据记录的地址，和主键索引一样，所以不需要再遍历一次主键索引）。
简单的说：
主索引的区别：InnoDB的数据文件本身就是索引文件。而MyISAM的索引和数据是分开的。
辅助索引的区别：InnoDB的辅助索引data域存储相应记录主键的值而不是地址。而MyISAM的辅助索引和主索引没有多大区别。

# 为什么尽量选择单调递增数值类型的主键
InnoDB中数据记录本身被存于主索引（B+树）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的结点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页。
如果使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引结点的后续位置，当一页写满，就会自动开辟一个新的页，这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。
如果使用非自增主键，由于每次插入主键的值近似于随机，因此每次新纪录都要被插入到现有索引页的中间某个位置，此时MySQL不得不为了将新记录查到合适位置而移动元素，甚至目标页可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过 OPTIMIZE TABLE 来重建表并优化填充页面。
简单的说：

索引树只能定位到某一页，每一页内的插入还是需要通过比较、移动插入的。所以有序主键可以提升插入效率。

# SQL调优

## 基本优化积累 
1. 比较运算符能用 "="就不用"<>"
"=" 增加了索引的使用几率。
2. 明知只有一条查询结果，就使用 "LIMIT 1"
"LIMIT 1"可以避免全表扫描，找到对应结果就不会再继续扫描了。
3. 为列选择合适的数据类型
能用TINYINT就不用SMALLINT，能用SMALLINT就不用INT，道理你懂的，磁盘和内存消耗越小越好嘛。
4. 将大的DELETE，UPDATE or INSERT 查询变成多个小查询
能写一个几十行、几百行的SQL语句是不是显得逼格很高？然而，为了达到更好的性能以及更好的数据控制，你可以将他们变成多个小查询。
5. 使用UNION ALL 代替 UNION，如果结果集允许重复的话
因为 UNION ALL 不去重，效率高于 UNION。
6. 为获得相同结果集的多次执行，请保持SQL语句前后一致
这样做的目的是为了充分利用查询缓冲。
比如根据地域和产品id查询产品价格，第一次使用了：
那么第二次同样的查询，请保持以上语句的一致性，比如不要将where语句里面的id和region位置调换顺序。
7. 尽量避免使用 "SELECT *"
如果不查询表中所有的列，尽量避免使用 SELECT *，因为它会进行全表扫描，不能有效利用索引，增大了数据库服务器的负担，以及它与应用程序客户端之间的网络IO开销。
8. WHERE 子句里面的列尽量被索引
只是"尽量"，并不是说所有的列。因地制宜，根据实际情况进行调整，因为有时索引太多也会降低性能。
9. JOIN 子句里面的列尽量被索引
同样只是尽量，并不是说所有的列。
10. ORDER BY 的列尽量被索引
ORDER BY的列如果被索引，性能也会更好。
11. 使用 LIMIT 实现分页逻辑
不仅提高了性能，同时减少了不必要的数据库和应用间的网络传输。
12. 使用 EXPLAIN 关键字去查看执行计划
EXPLAIN 可以检查索引使用情况以及扫描的行。