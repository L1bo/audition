[TOC]

# ACID规则
事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：

1. A (Atomicity) 原子性
原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。
比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。

2. C (Consistency) 一致性
一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。
例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。

3. I (Isolation) 独立性
所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。
比如现在有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。

4. D (Durability) 持久性
持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。

# SQL调优

## 基本优化积累 
1. 比较运算符能用 "="就不用"<>"
"=" 增加了索引的使用几率。
2. 明知只有一条查询结果，就使用 "LIMIT 1"
"LIMIT 1"可以避免全表扫描，找到对应结果就不会再继续扫描了。
3. 为列选择合适的数据类型
能用TINYINT就不用SMALLINT，能用SMALLINT就不用INT，道理你懂的，磁盘和内存消耗越小越好嘛。
4. 将大的DELETE，UPDATE or INSERT 查询变成多个小查询
能写一个几十行、几百行的SQL语句是不是显得逼格很高？然而，为了达到更好的性能以及更好的数据控制，你可以将他们变成多个小查询。
5. 使用UNION ALL 代替 UNION，如果结果集允许重复的话
因为 UNION ALL 不去重，效率高于 UNION。
6. 为获得相同结果集的多次执行，请保持SQL语句前后一致
这样做的目的是为了充分利用查询缓冲。
比如根据地域和产品id查询产品价格，第一次使用了：
那么第二次同样的查询，请保持以上语句的一致性，比如不要将where语句里面的id和region位置调换顺序。
7. 尽量避免使用 "SELECT *"
如果不查询表中所有的列，尽量避免使用 SELECT *，因为它会进行全表扫描，不能有效利用索引，增大了数据库服务器的负担，以及它与应用程序客户端之间的网络IO开销。
8. WHERE 子句里面的列尽量被索引
只是"尽量"，并不是说所有的列。因地制宜，根据实际情况进行调整，因为有时索引太多也会降低性能。
9. JOIN 子句里面的列尽量被索引
同样只是尽量，并不是说所有的列。
10. ORDER BY 的列尽量被索引
ORDER BY的列如果被索引，性能也会更好。
11. 使用 LIMIT 实现分页逻辑
不仅提高了性能，同时减少了不必要的数据库和应用间的网络传输。
12. 使用 EXPLAIN 关键字去查看执行计划
EXPLAIN 可以检查索引使用情况以及扫描的行。